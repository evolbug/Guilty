{
    "docs": [
        {
            "location": "/",
            "text": "Guilty - Love2D GUI library\n\u00b6\n\n\nGuilty is an open-source Love2D GUI library built with Moonscript and can be used with both Lua and Moonscript. It has no dependencies on external libraries, and is compiled to Lua, making it very compatible.\n\n\nIt's designed to be very customizable and themeable, and the component oriented architecture allows it to be extended even in Lua, without Moonscript's classes.\n\n\nBelow is a demo of the library: \n\n\n\n\nlocal\n \ngui\n \n=\n \nrequire\n \n\"guilty.guilty\"\n\n\nlocal\n \nLICENSE\n \n=\n \nrequire\n(\n'miscellaneous'\n).\nLICENSE\n\n\nlocal\n \nlg\n \n=\n \nlove\n.\ngraphics\n\n\n\nfunction\n \nWindow\n(\nx\n,\n \ny\n,\n \nw\n,\n \nh\n,\n \notherColor\n)\n\n    \nif\n \notherColor\n==\nnil\n \nthen\n \notherColor\n=\nfalse\n \nend\n\n    \nlocal\n \nwin\n \n=\n \ngui\n.\nContainer\n(\nx\n,\n \ny\n,\n \nw\n,\n \nh\n)\n\n    \nlocal\n \nbg\n \n=\n \nwin\n:\nattach\n(\ngui\n.\nRectangle\n(\n'center'\n,\n \n'center'\n,\n \nwin\n.\nw\n-\n2\n,\n \nwin\n.\nh\n-\n2\n))\n\n    \nif\n \notherColor\n \nthen\n\n        \nbg\n.\ntheme\n.\ncolor\n \n=\n \nfunction\n()\n \nreturn\n \ngui\n.\nRGBA\n(\ngui\n.\ntheme\n.\ncolor\n.\nsecondary\n)\n \nend\n\n    \nend\n\n    \nwin\n:\nattach\n(\ngui\n.\nBorder\n())\n\n    \nreturn\n \nwin\n\n\nend\n\n\n\n\nfunction\n \nlove\n.\nload\n()\n\n    \nlove\n.\nwindow\n.\nsetMode\n(\n500\n,\n400\n)\n\n    \nlove\n.\nkeyboard\n.\nsetKeyRepeat\n(\ntrue\n)\n\n\n    \n-- main window\n\n    \nwindow\n \n=\n \nWindow\n(\n'center'\n,\n'center'\n,\n \nlg\n.\ngetWidth\n()\n-\n10\n,\n \nlg\n.\ngetHeight\n()\n-\n10\n)\n\n    \nwindow\n:\nattach\n(\ngui\n.\nText\n(\n'center'\n,\n \n5\n,\n \n'evolbug 2016-2017, MIT license. Guilty .4'\n))\n\n\n\n    \n-- inner windows\n\n    \nlocal\n \nlicense\n \n=\n \nwindow\n:\nattach\n(\nWindow\n(\n'center'\n,\n \n20\n,\n \nwindow\n.\nw\n-\n10\n,\n \n200\n,\n \ntrue\n))\n\n        \nlocal\n \nltext\n \n=\n \nlicense\n:\nattach\n(\ngui\n.\nTextBoxScrollable\n(\n5\n,\n \n5\n,\n \nlicense\n.\nw\n-\n10\n,\n \nlicense\n.\nh\n-\n10\n))\n\n        \nltext\n.\ntext\n:\nset\n(\nLICENSE\n)\n\n\n     \nlocal\n \nwin2\n \n=\n \nwindow\n:\nattach\n(\nWindow\n(\n'center'\n,\n225\n,\n \nwindow\n.\nw\n-\n10\n,\n \nwindow\n.\nh\n-\n240\n,\n \ntrue\n))\n\n        \nlocal\n \ntextbax\n \n=\n \nwin2\n:\nattach\n(\ngui\n.\nTextBox\n(\n1\n,\n \n1\n,\n \nwin2\n.\nw\n/\n2\n,\n \nwin2\n.\nh\n-\n2\n))\n\n            \ntextbax\n.\ntext\n:\nset\n(\n\"Write text below and press the button to add it here\n\\n\n\"\n)\n\n\n        \nlocal\n \ninputbox\n \n=\n \nwin2\n:\nattach\n(\ngui\n.\nTextInput\n(\nwin2\n.\nw\n/\n2\n+\n2\n,\n \n2\n,\n \nwin2\n.\nw\n/\n2\n-\n4\n,\n \n40\n))\n\n            \ninputbox\n:\nattach\n(\ngui\n.\nBorder\n())\n\n\n        \nlocal\n \ntextbtn\n \n=\n \nwin2\n:\nattach\n(\ngui\n.\nButton\n(\nwin2\n.\nw\n/\n2\n+\n2\n,\n \n45\n,\n \nwin2\n.\nw\n/\n2\n-\n4\n,\n30\n,\n \n'Add text'\n))\n\n            \ntextbtn\n:\nattach\n(\ngui\n.\nBorder\n())\n\n            \ntextbtn\n.\nonclick\n.\nrelease\n \n=\n \nfunction\n()\n \ntextbax\n.\ntext\n:\nadd\n(\ninputbox\n.\ntext\n.\nbuffer\n)\n \nend\n\n\n        \n--extra container for checkboxes\n\n        \nlocal\n \nchecks\n \n=\n \nwin2\n:\nattach\n(\ngui\n.\nContainer\n(\nwin2\n.\nw\n/\n2\n+\n2\n,\n \n77\n,\n \nwin2\n.\nw\n/\n2\n-\n4\n,\n \n70\n))\n\n            \nchecks\n:\nattach\n(\ngui\n.\nBorder\n())\n\n            \nlocal\n \nch1\n \n=\n \nchecks\n:\nattach\n(\ngui\n.\nCheckbox\n(\n10\n,\n \n5\n,\n \n15\n,\n \n'show input and button'\n,\n \ntrue\n))\n\n                \nch1\n.\nonclick\n.\nany\n \n=\n \nfunction\n()\n\n                    \ntextbtn\n.\nvisible\n \n=\n \nch1\n.\nstate\n\n                    \ninputbox\n.\nvisible\n \n=\n \nch1\n.\nstate\n\n                \nend\n\n\n            \nlocal\n \nch2\n \n=\n \nchecks\n:\nattach\n(\ngui\n.\nCheckbox\n(\n10\n,\n \n28\n,\n \n15\n,\n \n'show text'\n,\n \ntrue\n))\n\n                \nch2\n.\nonclick\n.\nany\n \n=\n \nfunction\n()\n \ntextbax\n.\nvisible\n \n=\n \nch2\n.\nstate\n \nend\n\n\n            \nlocal\n \nch3\n \n=\n \nchecks\n:\nattach\n(\ngui\n.\nCheckbox\n(\n10\n,\n \n50\n,\n \n15\n,\n \n'show license'\n,\n \ntrue\n))\n\n                \nch3\n.\nonclick\n.\nany\n \n=\n \nfunction\n()\n \nlicense\n.\nvisible\n \n=\n \nch3\n.\nstate\n \nend\n\n\nend\n\n\n\nfunction\n \nlove\n.\ndraw\n()\n\n    \nlg\n.\nclear\n(\ngui\n.\nRGBA\n(\ngui\n.\ntheme\n.\ncolor\n.\nsecondary\n))\n\n    \nwindow\n:\ndraw\n()\n\n\nend\n\n\n\nfunction\n \nlove\n.\nupdate\n(\ndt\n)\n \ndo\n \nwindow\n:\nevent\n{[\n'delta'\n]\n=\n{\ndt\n}}\n \nend\n\n\n\nfunction\n \nlove\n.\ntextinput\n(\ntext\n)\n \ndo\n \nwindow\n:\nevent\n{[\n'textinput'\n]\n=\n{\ntext\n}}\n \nend\n\n\n\nfunction\n \nlove\n.\nkeypressed\n(\nkey\n)\n \ndo\n \nwindow\n:\nevent\n{[\n'keypress'\n]\n=\n{\nkey\n}}\n \nend\n\n\n\nfunction\n \nlove\n.\nmousepressed\n(\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n)\n \ndo\n \nwindow\n:\nevent\n{[\n'mousepress'\n]\n=\n{\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n}}\n \nend\n\n\n\nfunction\n \nlove\n.\nmousereleased\n(\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n)\n \ndo\n \nwindow\n:\nevent\n{[\n'mouserelease'\n]\n=\n{\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n}}\n \nend\n\n\n\nfunction\n \nlove\n.\nwheelmoved\n(\nx\n,\n \ny\n)\n \ndo\n \nwindow\n:\nevent\n{[\n'wheelmove'\n]\n=\n{\nx\n,\n \ny\n}}\n \nend\n\n\n\nfunction\n \nlove\n.\nmousemoved\n(\nx\n,\n \ny\n)\n \ndo\n \nwindow\n:\nevent\n{[\n'mousemove'\n]\n=\n{\nx\n,\n \ny\n}}\n \nend",
            "title": "Home"
        },
        {
            "location": "/#guilty-love2d-gui-library",
            "text": "Guilty is an open-source Love2D GUI library built with Moonscript and can be used with both Lua and Moonscript. It has no dependencies on external libraries, and is compiled to Lua, making it very compatible.  It's designed to be very customizable and themeable, and the component oriented architecture allows it to be extended even in Lua, without Moonscript's classes.  Below is a demo of the library:    local   gui   =   require   \"guilty.guilty\"  local   LICENSE   =   require ( 'miscellaneous' ). LICENSE  local   lg   =   love . graphics  function   Window ( x ,   y ,   w ,   h ,   otherColor ) \n     if   otherColor == nil   then   otherColor = false   end \n     local   win   =   gui . Container ( x ,   y ,   w ,   h ) \n     local   bg   =   win : attach ( gui . Rectangle ( 'center' ,   'center' ,   win . w - 2 ,   win . h - 2 )) \n     if   otherColor   then \n         bg . theme . color   =   function ()   return   gui . RGBA ( gui . theme . color . secondary )   end \n     end \n     win : attach ( gui . Border ()) \n     return   win  end  function   love . load () \n     love . window . setMode ( 500 , 400 ) \n     love . keyboard . setKeyRepeat ( true ) \n\n     -- main window \n     window   =   Window ( 'center' , 'center' ,   lg . getWidth () - 10 ,   lg . getHeight () - 10 ) \n     window : attach ( gui . Text ( 'center' ,   5 ,   'evolbug 2016-2017, MIT license. Guilty .4' )) \n\n\n     -- inner windows \n     local   license   =   window : attach ( Window ( 'center' ,   20 ,   window . w - 10 ,   200 ,   true )) \n         local   ltext   =   license : attach ( gui . TextBoxScrollable ( 5 ,   5 ,   license . w - 10 ,   license . h - 10 )) \n         ltext . text : set ( LICENSE ) \n\n      local   win2   =   window : attach ( Window ( 'center' , 225 ,   window . w - 10 ,   window . h - 240 ,   true )) \n         local   textbax   =   win2 : attach ( gui . TextBox ( 1 ,   1 ,   win2 . w / 2 ,   win2 . h - 2 )) \n             textbax . text : set ( \"Write text below and press the button to add it here \\n \" ) \n\n         local   inputbox   =   win2 : attach ( gui . TextInput ( win2 . w / 2 + 2 ,   2 ,   win2 . w / 2 - 4 ,   40 )) \n             inputbox : attach ( gui . Border ()) \n\n         local   textbtn   =   win2 : attach ( gui . Button ( win2 . w / 2 + 2 ,   45 ,   win2 . w / 2 - 4 , 30 ,   'Add text' )) \n             textbtn : attach ( gui . Border ()) \n             textbtn . onclick . release   =   function ()   textbax . text : add ( inputbox . text . buffer )   end \n\n         --extra container for checkboxes \n         local   checks   =   win2 : attach ( gui . Container ( win2 . w / 2 + 2 ,   77 ,   win2 . w / 2 - 4 ,   70 )) \n             checks : attach ( gui . Border ()) \n             local   ch1   =   checks : attach ( gui . Checkbox ( 10 ,   5 ,   15 ,   'show input and button' ,   true )) \n                 ch1 . onclick . any   =   function () \n                     textbtn . visible   =   ch1 . state \n                     inputbox . visible   =   ch1 . state \n                 end \n\n             local   ch2   =   checks : attach ( gui . Checkbox ( 10 ,   28 ,   15 ,   'show text' ,   true )) \n                 ch2 . onclick . any   =   function ()   textbax . visible   =   ch2 . state   end \n\n             local   ch3   =   checks : attach ( gui . Checkbox ( 10 ,   50 ,   15 ,   'show license' ,   true )) \n                 ch3 . onclick . any   =   function ()   license . visible   =   ch3 . state   end  end  function   love . draw () \n     lg . clear ( gui . RGBA ( gui . theme . color . secondary )) \n     window : draw ()  end  function   love . update ( dt )   do   window : event {[ 'delta' ] = { dt }}   end  function   love . textinput ( text )   do   window : event {[ 'textinput' ] = { text }}   end  function   love . keypressed ( key )   do   window : event {[ 'keypress' ] = { key }}   end  function   love . mousepressed ( x ,   y ,   button ,   istouch )   do   window : event {[ 'mousepress' ] = { x ,   y ,   button ,   istouch }}   end  function   love . mousereleased ( x ,   y ,   button ,   istouch )   do   window : event {[ 'mouserelease' ] = { x ,   y ,   button ,   istouch }}   end  function   love . wheelmoved ( x ,   y )   do   window : event {[ 'wheelmove' ] = { x ,   y }}   end  function   love . mousemoved ( x ,   y )   do   window : event {[ 'mousemove' ] = { x ,   y }}   end",
            "title": "Guilty - Love2D GUI library"
        },
        {
            "location": "/classes/",
            "text": "class { border-left: 4px solid #08D7; padding: 5px 20px;}\n    .admonition-title { font-family: 'Fira Code'; font-weight: 500 }\n    .admonition-title > em, i { color: #0006; font-weight: 400; }\n    .admonition-title > strong, b { color: #08df }\n    .admonition { font-family: 'Fira Code'; font-weight: 400;}\n    .md-typeset .codehilite { background-color: transparent; border: 1px solid #08d6}\n    desc { position: relative; left: 5px; color: #0009; }\n\n\n\n\nClasses\n\u00b6\n\n\nThere are 3 categories for Guilty's classes.\n\n\n\n\nPrimitives\n\n\nExtensions\n\n\nComposites\n\n\n\n\nTheir relations are simple, Primitives are the most basic components, providing base building blocks for Composites, i.e. the widgets themselves. Extensions are what give Composites their functionality, like making them responsive to clicks, text input, etc.\n\n\nBelow each class is described with properties, methods and events they can receive.\n\n\n\n\ntype\n \nproperty_name\n\n\nThis describes properties\n\n\n\n\n\n\nEvents\n\n\nfunction\n \nlove\n.\n<\nevent\n>\n()\n\n    \nwidget\n:\nevent\n(\n<\nevent\n>\n)\n\n\nend\n\n\n\n\n\nThis block describes events\n\n\n\n\n\n\n:method( \ntype\n \nname\n ) \n\u2192 nil\n\n\nThis is a method definition\n\n\n\n\n\n\nThe class descriptions show only differences from their parent class. To collect all functions and properties a class has, look at the class they extend.\n\n\n\n\nComponents\n\u00b6\n\n\nComponent\n\u00b6\n\n\nGuilty is built on a component framework called Comfy, and thus all classes of Guilty possess these methods and properties:\n\n\nclass\n \nComponent\n\n\n\n\n\n\n\n\nComponent() \n\u2192 self\n\n\n\n\n\n\ntable\n \nchildren\n\n\na list containing all attached children\n\n\nComponent\n \nparent\n\n\nthe component this one is attached to\n\n\n\n\n\n\n:attach(\nComponent\n \n...\n) \n\u2192 ...\n\n\n\nAttaches other \nchild\n to self and collects it in \nchildren\n.\nThe attached \nchild\n's \nparent\n will be set to \nself\n.\n\nThis function is used most often to attach elements to one another, e.g. attach a \nButton\n to a \nContainer\n.\n\n\n\n\n\nAttaching \nchild\n will override its variable \nparent\n.\n\nA component should be attached to only one parent.\n\n\n\n\n\n\n\n\n:detach(\nComponent\n \nchild\n) \n\u2192 nil\n\n\n\nDetaches \nchild\n from self, removing it from \nchildren\n.\n\n\n\n\n\n\n\n:event(\ntable\n \nevents\n) \n\u2192 nil\n\n\n\nStandard event propagation. Push \nevents\n down to all \nchildren\n.\n\nEvents are handled first-come-first-serve.\n\n\n\n\n\n\n\n:bubble(\ntable\n \nevents\n) \n\u2192 nil\n\n\n\nPush-down-bubble event propagation. Push \nevents\n down to all \nchildren\n but handle bottom-up.\n\nEvents are handled starting from the deepest child in the tree upwards.\n\n\n\n\n\n\n\n:rise(\ntable\n \nevents\n) \n\u2192 nil\n\n\n\nRising event propagation. Push \nevents\n up to \nparent\n.\n\nEvents are handled by \nparent\ns, pushing them upwards with \n:rise()\n until the topmost \nparent\n is reached.\n\n\n\n\n\nPrimitives\n\u00b6\n\n\nPrimitives are used to build more complex widgets, although they can be used on their own.\n\n\nWidgetBase\n\u00b6\n\n\nWidgetBase\n is the base of all widget classes. It provides and manages the bare necessities of a widget.\n\n\nclass\n \nWidgetBase\n \nextends\n \nComponent\n\n\n\n\n\n\n\n\nWidgetBase(\nnumber\n \nx\n, \nnumber\n \ny\n, \nnumber\n \nw\n, \nnumber\n \nh\n) \n\u2192 self\n\n\n\n\n\n\nnumber\n \nx\n, \ny\n\n\nposition relative to parent. Can have a special value \n'center'\n which centers it in the parent.\n\n\nnumber\n \nw\n, \nh\n\n\nwidget size\n\n\nbool\n \nupdate\n\n\na flag that tells if a widget must be rerendered\n\n\nbool\n \nvisible\n = true\n\n\nwidget visibility flag\n\n\ntable\n \ntheme\n = \nTheme\n(theme[\n<widget name>\n])\n\n\nwidget's theme. It's automatically found in the global theme table. See \nTheming\n\n\n\n\n\n\nEvents\n\n\nwidget\n:\nrise\n(\n'update'\n)\n\n\n\n\n\nThis event is used to signal that a branch of dependant widgets should be rerendered\n\n\n\n\n\n\n:absolute() \n\u2192\n \nnumber\n \nx\n, number\n \ny\n\n\nreturns absolute widget position on screen\n\n\n\n\n\n\n:relative() \n\u2192\n \nnumber\n \nx\n, number\n \ny\n\n\nreturns widget position relative to parent. Usually the position given on creation, or, if it's the special value \n'center'\n, will calculate the center of parent widget.\n\n\n\n\n\n\n:draw() \n\u2192 nil\n\n\ndraws the widget with it's children\n\n\n\n\n\n\n:colored(\nfunction\n \nfunc\n, \n...\n) \n\u2192 nil\n\n\ndraws a \nlove.graphics\n primitive with theme colors\n\n\n\n\nRectangle\n\u00b6\n\n\nRectangle\n is a \nlove.graphics.rectangle\n wrapped in \nWidgetBase\n for use as a widget component\n\n\nclass\n \nRectangle\n \nextends\n \nWidgetBase\n\n\n\n\n\n\n\n\nRectangle(\nnumber\n \nx\n, \nnumber\n \ny\n, \nnumber\n \nw\n, \nnumber\n \nh\n) \n\u2192 self\n\n\n\n\nText\n\u00b6\n\n\nText\n can be used on it's own as a label or formatted text. Colored text format ({color, string, ...}) shouldn't be used.\n\n\nclass\n \nText\n \nextends\n \nWidgetBase\n\n\n\n\n\n\n\n\nText(\nnumber\n \nx\n, \nnumber\n \ny\n, \nstring\n \ntext\n) \n\u2192 self\n\n\n\n\n\n\nstring\n \nbuffer\n = text\n\n\ninternal string buffer for easier manipulation. Shouldn't be manipulated directly\n\n\nlove.Text\n \ntext\n\n\nthe actual text object. Shouldn't be manipulated directly\n\n\n\n\n\n\n:refresh() \n\u2192 nil\n\n\nrefreshes text widget's size and position (\ny\n, \nw\n and \nh\n). Used internally, should be called each time \ntext\n is manipulated\n\n\n\n\n\n\n:set(\nstring\n \ntext\n, \nnumber\n \nwrap\n=parent.w, \nstring\n \nalign\n='left') \n\u2192 nil\n\n\nset \nbuffer\n to \ntext\n and update the \nlove.Text\n object\n\n\n\n\n\n\n:add(\nstring\n \ntext\n, \nnumber\n \nwrap\n=parent.w, \nstring\n \nalign\n='left') \n\u2192 nil\n\n\nadd \ntext\n to \nbuffer\n and update the \nlove.Text\n object\n\n\n\n\n\n\n:remove(\nnumber\n \na\n=#buffer-1, \nnumber\n \nb\n=#buffer) \n\u2192 nil\n\n\nremove characters from \nbuffer\n, starting from \na\n to \nb\n, and update the \nlove.Text\n object\n\n\n\n\n\n\n:clear() \n\u2192 nil\n\n\nerase \nbuffer\n and reset \nlove.Text\n object\n\n\n\n\nComposites\n\u00b6\n\n\nComposites\n are widgets that are built from \nPrimitives\n and \nExtensions\n. They must be attached to a \nContainer\n to be rendered.\n\n\nContainer\n\u00b6\n\n\nThe container is the base of all Composites. It's most basic use is a rendering window. Widgets must be \n:attach()\n -ed to a container, and the container must be \n:draw()\n -n.\n\n\nclass\n \nContainer\n \nextends\n \nWidgetBase\n\n\n\n\n\n\n\n\nContainer(\nnumber\n \nx\n, \nnumber\n \ny\n, \nnumber\n \nw\n, \nnumber\n \nh\n) \n\u2192 self\n\n\nCreates a new Container object that stores and renders attached widgets\n\n\n\n\n\n\nlove.Canvas\n \ncanvas\n\n\nattached widgets get rendered to this canvas\n\n\n\n\n\n\n:draw() \n\u2192 nil\n\n\nRenders the container with all attached widgets\n\n\n\n\nfunction\n \nlove\n.\nload\n()\n\n  \nwindow\n \n=\n \nContainer\n(\n10\n,\n \n10\n,\n \n200\n,\n \n200\n)\n\n\nend\n\n\n\nfunction\n \nlove\n.\ndraw\n()\n\n  \nwindow\n:\ndraw\n()\n\n\nend\n\n\n\n\n\n\nButton\n\u00b6\n\n\nclass\n \nButton\n \nextends\n \nContainer\n\n\n\n\n\n\n\n\nButton(\nnumber\n \nx\n, \nnumber\n \ny\n, \nnumber\n \nw\n, \nnumber\n \nh\n, \nstring\n \nlabel\n) \n\u2192 self\n\n\n\n\n\n\nRectangle\n \npanel\n\n\nButton background panel\n\n\nText\n \ntext\n\n\nButton label Text object\n\n\nClickable\n \nonclick\n\n\nClickable\n extension, makes button clickable\n\n\n\n\n\n\nfunction\n \nlove\n.\nmousepressed\n(\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n)\n\n    \nContainer\n:\nevent\n{[\n'mousepress'\n]\n=\n{\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n}}\n\n\nend\n\n\n\nfunction\n \nlove\n.\nmousereleased\n(\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n)\n\n    \nContainer\n:\nevent\n{[\n'mouserelease'\n]\n=\n{\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n}}\n\n\nend\n\n\n\n\n\n\n\n\nfunction\n \nlove\n.\nload\n()\n\n    \nwindow\n \n=\n \nContainer\n(\n0\n,\n \n0\n,\n \n100\n,\n \n100\n)\n\n    \nmybutton\n \n=\n \nwindow\n:\nattach\n(\nButton\n(\n10\n,\n \n10\n,\n \n100\n,\n \n20\n,\n \n'Button'\n))\n\n\n    \nmybutton\n.\nonclick\n.\nprimary\n \n=\n \nfunction\n(\nx\n,\n \ny\n)\n \n-- callback\n\n        \nprint\n(\n\"hello at x:\"\n..\ntostring\n(\nx\n)\n..\n\" y:\"\n..\ntostring\n(\ny\n))\n\n    \nend\n\n\nend\n\n\n\n\n\n\nCheckbox\n\u00b6\n\n\nclass\n \nCheckbox\n \nextends\n \nContainer\n\n\n\n\n\n\n\n\nCheckbox(\nnumber\n \nx\n, \nnumber\n \ny\n, \nnumber\n \nradius\n, \nstring\n \ntext\n, \nbool\n \nstate\n) \n\u2192 self\n\n\n\n\n\n\nRectangle\n \nbase\n\n\nCheckbox base panel\n\n\nRectangle\n \ncheck\n\n\nthe \"check\" itself\n\n\nText\n \ntext\n\n\ncheckbox's label\n\n\nClickable\n \nonclick\n\n\nClickable\n extension\n\n\nbool\n \nstate\n=false\n\n\ncurrent state of the checkbox\n\n\n\n\n\n\nfunction\n \nlove\n.\nmousepressed\n(\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n)\n\n    \nContainer\n:\nevent\n{[\n'mousepress'\n]\n=\n{\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n}}\n\n\nend\n\n\n\n\n\n\n\n\n\n\n:toggle() \n\u2192 nil\n\n\ncalled when checkbox is clicked, toggles state. Do not override\n\n\n\n\nfunction\n \nlove\n.\nload\n()\n\n    \nwindow\n \n=\n \nContainer\n(\n0\n,\n \n0\n,\n \n100\n,\n \n100\n)\n\n    \nmycheck\n \n=\n \nwindow\n:\nattach\n(\nCheckbox\n(\n10\n,\n \n10\n,\n \n80\n,\n \n20\n,\n \n'Checkbox'\n))\n\n\nend\n\n\n\n\n\n\nTextBox\n\u00b6\n\n\nclass\n \nTextBox\n \nextends\n \nContainer\n\n\n\n\n\n\n\n\nTextBox(\nnumber\n \nx\n, \nnumber\n \ny\n, \nnumber\n \nw\n, \nnumber\n \nh\n) \n\u2192 self\n\n\n\n\n\n\nRectangle\n \nbase\n\n\nTextBox base panel\n\n\nText\n \ntext\n\n\nInteract with this Primitive to set, add, remove text\n\n\n\n\nfunction\n \nlove\n.\nload\n()\n\n    \nwindow\n \n=\n \nContainer\n(\n0\n,\n \n0\n,\n \n100\n,\n \n100\n)\n\n    \nmytext\n \n=\n \nwindow\n:\nattach\n(\nTextBox\n(\n10\n,\n \n10\n,\n \n80\n,\n \n80\n))\n\n\n    \nmytext\n:\nadd\n(\n'hello world!\n\\n\n'\n)\n\n\nend\n\n\n\n\n\n\nTextBoxScrollable\n\u00b6\n\n\nclass\n \nTextBoxScrollable\n \nextends\n \nTextBox\n\n\n\n\n\n\n\n\nTextBoxScrollable(\nnumber\n \nx\n, \nnumber\n \ny\n, \nnumber\n \nw\n, \nnumber\n \nh\n) \n\u2192 self\n\n\n\n\n\n\nFocus\n \nfocus\n = Focus('mousemove')\n\n\nFocuses on TextBox when mouse is hovering above it\n\n\nScroll\n \nscroller\n\n\nScroll extension, allows widget to be scrolled\n\n\nScrollBar\n \nscrollbar\n\n\nScrollBar extension, adds a scrollbar element based on \nscroller\n values\n\n\n\n\n\n\nfunction\n \nlove\n.\nmousemoved\n(\nx\n,\n \ny\n)\n\n    \nContainer\n:\nevent\n{[\n'mousemove'\n]\n=\n{\nx\n,\n \ny\n}}\n\n\nend\n\n\n\nfunction\n \nlove\n.\nwheelmoved\n(\nx\n,\n \ny\n)\n\n    \nContainer\n:\nevent\n{[\n'wheelmove'\n]\n=\n{\nx\n,\n \ny\n}}\n\n\nend\n\n\n\n\n\n\n\n\nfunction\n \nlove\n.\nload\n()\n\n    \nwindow\n \n=\n \nContainer\n(\n0\n,\n \n0\n,\n \n100\n,\n \n100\n)\n\n    \nmytext\n \n=\n \nwindow\n:\nattach\n(\nTextBoxScrollable\n(\n10\n,\n \n10\n,\n \n80\n,\n \n20\n))\n\n\n    \nmytext\n:\nset\n(\n'imagine a lot of text here'\n)\n\n\nend\n\n\n\n\n\n\nTextInput\n\u00b6\n\n\nclass\n \nTextInput\n \nextends\n \nTextBox\n\n\n\n\n\n\n\n\nTextInput(\nnumber\n \nx\n, \nnumber\n \ny\n, \nnumber\n \nw\n, \nnumber\n \nh\n) \n\u2192 self\n\n\n\n\n\n\nFocus\n \nfocus\n = Focus('mousepress')\n\n\nFocuses on TextInput when mouse is clicked\n\n\nstring\n \nbuffer\n\n\ninternal string buffer for easier manipulation. Shouldn't be manipulated directly\n\n\nBlinkingCursor\n \ncursor\n\n\nCursor extension, blinks every .7 seconds\n\n\nInput\n\n\nInput extension, allows widget to receive keyboard input\n\n\n\n\n\n\nfunction\n \nlove\n.\nmousepressed\n(\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n)\n\n    \nContainer\n:\nevent\n{[\n'mousepress'\n]\n=\n{\nx\n,\n \ny\n,\n \nbutton\n,\n \nistouch\n}}\n\n\nend\n\n\n\nfunction\n \nlove\n.\nkeypressed\n(\nkey\n)\n\n    \nContainer\n:\nevent\n{[\n'keypress'\n]\n=\n{\nkey\n}}\n\n\nend\n\n\n\nfunction\n \nlove\n.\ntextinput\n(\ntext\n)\n\n    \nContainer\n:\nevent\n{[\n'textinput'\n]\n=\n{\ntext\n}}\n\n\nend\n\n\n\nfunction\n \nlove\n.\nupdate\n(\ndt\n)\n\n    \nContainer\n:\nevent\n{[\n'delta'\n]\n=\n{\ndt\n}}\n\n\nend\n\n\n\n\n\n\n\n\nfunction\n \nlove\n.\nload\n()\n\n    \nlove\n.\nkeyboard\n.\nsetKeyRepeat\n(\ntrue\n)\n\n\n    \nwindow\n \n=\n \nContainer\n(\n0\n,\n \n0\n,\n \n100\n,\n \n100\n)\n\n    \nmyinput\n \n=\n \nwindow\n:\nattach\n(\nTextInput\n(\n10\n,\n \n10\n,\n \n80\n,\n \n20\n))\n\n\nend",
            "title": "Classes"
        },
        {
            "location": "/classes/#classes",
            "text": "There are 3 categories for Guilty's classes.   Primitives  Extensions  Composites   Their relations are simple, Primitives are the most basic components, providing base building blocks for Composites, i.e. the widgets themselves. Extensions are what give Composites their functionality, like making them responsive to clicks, text input, etc.  Below each class is described with properties, methods and events they can receive.   type   property_name  This describes properties    Events  function   love . < event > () \n     widget : event ( < event > )  end   This block describes events    :method(  type   name  )  \u2192 nil  This is a method definition    The class descriptions show only differences from their parent class. To collect all functions and properties a class has, look at the class they extend.",
            "title": "Classes"
        },
        {
            "location": "/classes/#components",
            "text": "",
            "title": "Components"
        },
        {
            "location": "/classes/#component",
            "text": "Guilty is built on a component framework called Comfy, and thus all classes of Guilty possess these methods and properties:  class   Component    Component()  \u2192 self    table   children  a list containing all attached children  Component   parent  the component this one is attached to    :attach( Component   ... )  \u2192 ...  \nAttaches other  child  to self and collects it in  children .\nThe attached  child 's  parent  will be set to  self . \nThis function is used most often to attach elements to one another, e.g. attach a  Button  to a  Container .   Attaching  child  will override its variable  parent . \nA component should be attached to only one parent.     :detach( Component   child )  \u2192 nil  \nDetaches  child  from self, removing it from  children .    :event( table   events )  \u2192 nil  \nStandard event propagation. Push  events  down to all  children . \nEvents are handled first-come-first-serve.    :bubble( table   events )  \u2192 nil  \nPush-down-bubble event propagation. Push  events  down to all  children  but handle bottom-up. \nEvents are handled starting from the deepest child in the tree upwards.    :rise( table   events )  \u2192 nil  \nRising event propagation. Push  events  up to  parent . \nEvents are handled by  parent s, pushing them upwards with  :rise()  until the topmost  parent  is reached.",
            "title": "Component"
        },
        {
            "location": "/classes/#primitives",
            "text": "Primitives are used to build more complex widgets, although they can be used on their own.",
            "title": "Primitives"
        },
        {
            "location": "/classes/#widgetbase",
            "text": "WidgetBase  is the base of all widget classes. It provides and manages the bare necessities of a widget.  class   WidgetBase   extends   Component    WidgetBase( number   x ,  number   y ,  number   w ,  number   h )  \u2192 self    number   x ,  y  position relative to parent. Can have a special value  'center'  which centers it in the parent.  number   w ,  h  widget size  bool   update  a flag that tells if a widget must be rerendered  bool   visible  = true  widget visibility flag  table   theme  =  Theme (theme[ <widget name> ])  widget's theme. It's automatically found in the global theme table. See  Theming    Events  widget : rise ( 'update' )   This event is used to signal that a branch of dependant widgets should be rerendered    :absolute()  \u2192   number   x , number   y  returns absolute widget position on screen    :relative()  \u2192   number   x , number   y  returns widget position relative to parent. Usually the position given on creation, or, if it's the special value  'center' , will calculate the center of parent widget.    :draw()  \u2192 nil  draws the widget with it's children    :colored( function   func ,  ... )  \u2192 nil  draws a  love.graphics  primitive with theme colors",
            "title": "WidgetBase"
        },
        {
            "location": "/classes/#rectangle",
            "text": "Rectangle  is a  love.graphics.rectangle  wrapped in  WidgetBase  for use as a widget component  class   Rectangle   extends   WidgetBase    Rectangle( number   x ,  number   y ,  number   w ,  number   h )  \u2192 self",
            "title": "Rectangle"
        },
        {
            "location": "/classes/#text",
            "text": "Text  can be used on it's own as a label or formatted text. Colored text format ({color, string, ...}) shouldn't be used.  class   Text   extends   WidgetBase    Text( number   x ,  number   y ,  string   text )  \u2192 self    string   buffer  = text  internal string buffer for easier manipulation. Shouldn't be manipulated directly  love.Text   text  the actual text object. Shouldn't be manipulated directly    :refresh()  \u2192 nil  refreshes text widget's size and position ( y ,  w  and  h ). Used internally, should be called each time  text  is manipulated    :set( string   text ,  number   wrap =parent.w,  string   align ='left')  \u2192 nil  set  buffer  to  text  and update the  love.Text  object    :add( string   text ,  number   wrap =parent.w,  string   align ='left')  \u2192 nil  add  text  to  buffer  and update the  love.Text  object    :remove( number   a =#buffer-1,  number   b =#buffer)  \u2192 nil  remove characters from  buffer , starting from  a  to  b , and update the  love.Text  object    :clear()  \u2192 nil  erase  buffer  and reset  love.Text  object",
            "title": "Text"
        },
        {
            "location": "/classes/#composites",
            "text": "Composites  are widgets that are built from  Primitives  and  Extensions . They must be attached to a  Container  to be rendered.",
            "title": "Composites"
        },
        {
            "location": "/classes/#container",
            "text": "The container is the base of all Composites. It's most basic use is a rendering window. Widgets must be  :attach()  -ed to a container, and the container must be  :draw()  -n.  class   Container   extends   WidgetBase    Container( number   x ,  number   y ,  number   w ,  number   h )  \u2192 self  Creates a new Container object that stores and renders attached widgets    love.Canvas   canvas  attached widgets get rendered to this canvas    :draw()  \u2192 nil  Renders the container with all attached widgets   function   love . load () \n   window   =   Container ( 10 ,   10 ,   200 ,   200 )  end  function   love . draw () \n   window : draw ()  end",
            "title": "Container"
        },
        {
            "location": "/classes/#button",
            "text": "class   Button   extends   Container    Button( number   x ,  number   y ,  number   w ,  number   h ,  string   label )  \u2192 self    Rectangle   panel  Button background panel  Text   text  Button label Text object  Clickable   onclick  Clickable  extension, makes button clickable    function   love . mousepressed ( x ,   y ,   button ,   istouch ) \n     Container : event {[ 'mousepress' ] = { x ,   y ,   button ,   istouch }}  end  function   love . mousereleased ( x ,   y ,   button ,   istouch ) \n     Container : event {[ 'mouserelease' ] = { x ,   y ,   button ,   istouch }}  end    function   love . load () \n     window   =   Container ( 0 ,   0 ,   100 ,   100 ) \n     mybutton   =   window : attach ( Button ( 10 ,   10 ,   100 ,   20 ,   'Button' )) \n\n     mybutton . onclick . primary   =   function ( x ,   y )   -- callback \n         print ( \"hello at x:\" .. tostring ( x ) .. \" y:\" .. tostring ( y )) \n     end  end",
            "title": "Button"
        },
        {
            "location": "/classes/#checkbox",
            "text": "class   Checkbox   extends   Container    Checkbox( number   x ,  number   y ,  number   radius ,  string   text ,  bool   state )  \u2192 self    Rectangle   base  Checkbox base panel  Rectangle   check  the \"check\" itself  Text   text  checkbox's label  Clickable   onclick  Clickable  extension  bool   state =false  current state of the checkbox    function   love . mousepressed ( x ,   y ,   button ,   istouch ) \n     Container : event {[ 'mousepress' ] = { x ,   y ,   button ,   istouch }}  end     :toggle()  \u2192 nil  called when checkbox is clicked, toggles state. Do not override   function   love . load () \n     window   =   Container ( 0 ,   0 ,   100 ,   100 ) \n     mycheck   =   window : attach ( Checkbox ( 10 ,   10 ,   80 ,   20 ,   'Checkbox' ))  end",
            "title": "Checkbox"
        },
        {
            "location": "/classes/#textbox",
            "text": "class   TextBox   extends   Container    TextBox( number   x ,  number   y ,  number   w ,  number   h )  \u2192 self    Rectangle   base  TextBox base panel  Text   text  Interact with this Primitive to set, add, remove text   function   love . load () \n     window   =   Container ( 0 ,   0 ,   100 ,   100 ) \n     mytext   =   window : attach ( TextBox ( 10 ,   10 ,   80 ,   80 )) \n\n     mytext : add ( 'hello world! \\n ' )  end",
            "title": "TextBox"
        },
        {
            "location": "/classes/#textboxscrollable",
            "text": "class   TextBoxScrollable   extends   TextBox    TextBoxScrollable( number   x ,  number   y ,  number   w ,  number   h )  \u2192 self    Focus   focus  = Focus('mousemove')  Focuses on TextBox when mouse is hovering above it  Scroll   scroller  Scroll extension, allows widget to be scrolled  ScrollBar   scrollbar  ScrollBar extension, adds a scrollbar element based on  scroller  values    function   love . mousemoved ( x ,   y ) \n     Container : event {[ 'mousemove' ] = { x ,   y }}  end  function   love . wheelmoved ( x ,   y ) \n     Container : event {[ 'wheelmove' ] = { x ,   y }}  end    function   love . load () \n     window   =   Container ( 0 ,   0 ,   100 ,   100 ) \n     mytext   =   window : attach ( TextBoxScrollable ( 10 ,   10 ,   80 ,   20 )) \n\n     mytext : set ( 'imagine a lot of text here' )  end",
            "title": "TextBoxScrollable"
        },
        {
            "location": "/classes/#textinput",
            "text": "class   TextInput   extends   TextBox    TextInput( number   x ,  number   y ,  number   w ,  number   h )  \u2192 self    Focus   focus  = Focus('mousepress')  Focuses on TextInput when mouse is clicked  string   buffer  internal string buffer for easier manipulation. Shouldn't be manipulated directly  BlinkingCursor   cursor  Cursor extension, blinks every .7 seconds  Input  Input extension, allows widget to receive keyboard input    function   love . mousepressed ( x ,   y ,   button ,   istouch ) \n     Container : event {[ 'mousepress' ] = { x ,   y ,   button ,   istouch }}  end  function   love . keypressed ( key ) \n     Container : event {[ 'keypress' ] = { key }}  end  function   love . textinput ( text ) \n     Container : event {[ 'textinput' ] = { text }}  end  function   love . update ( dt ) \n     Container : event {[ 'delta' ] = { dt }}  end    function   love . load () \n     love . keyboard . setKeyRepeat ( true ) \n\n     window   =   Container ( 0 ,   0 ,   100 ,   100 ) \n     myinput   =   window : attach ( TextInput ( 10 ,   10 ,   80 ,   20 ))  end",
            "title": "TextInput"
        }
    ]
}